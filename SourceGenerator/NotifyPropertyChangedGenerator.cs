using System.Collections.Immutable;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;
using static Microsoft.CodeAnalysis.CSharp.SyntaxFactory;


namespace SourceGenerator;

[Generator]
public sealed class ClassNameListGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var provider = context.SyntaxProvider.CreateSyntaxProvider((node, _) => Filter(node),
                                                                   (syntax, _) => GetRegistration(syntax))
                              .Where(t => t is not null)
                              .Select((t, _) => (ClassRegistration)t!);

        context.RegisterSourceOutput(provider.Collect(), Build);
    }

    private static bool Filter(SyntaxNode node)
    {
        if (node is not ClassDeclarationSyntax cds)
            return false;

        if (cds.BaseList is null)
            return false;

        foreach (var baseType in cds.BaseList.Types)
        {
            var typeSyntax = baseType.Type;

            if (typeSyntax is IdentifierNameSyntax identifierName)
            {
                if (identifierName.Identifier.Text == "INotifyPropertyChanged")
                {
                    return true;
                }
            }
        }

        return false;
    }

    private static ClassRegistration? GetRegistration(GeneratorSyntaxContext context)
    {
        var childNodes = context.Node.ChildNodes();

        var items = new List<PropertyItem>();

        foreach (var node in childNodes.OfType<PropertyDeclarationSyntax>())
        {
            var nameText = node.Identifier.Text;

            if (!nameText.Contains("BackingField"))
                continue;

            var type = node.Type.ToString();
            var item = new PropertyItem(fieldName: nameText.Replace("BackingField", string.Empty), fieldType: type);
            items.Add(item);
        }

        var classSymbol = ModelExtensions.GetDeclaredSymbol(context.SemanticModel, (ClassDeclarationSyntax)context.Node);
        if (classSymbol is null)
            return null;

        string? ns = null;

        if (!classSymbol.ContainingNamespace.IsGlobalNamespace)
            ns = classSymbol.ContainingNamespace.ToDisplayString();

        return new ClassRegistration(classNamespace: ns,
                                     className: classSymbol.Name,
                                     items: items);
    }

    private static void Build(
        SourceProductionContext context,
        // Compilation compilation,
        ImmutableArray<ClassRegistration> source)
    {
        try
        {
            foreach (var item in source)
            {
                var enumObjectClass = GenerateClass(classRegistration: item);

                var compilationUnit = CompilationUnit();

                var ns = item.ClassNamespace;
                if (ns is null)
                {
                    compilationUnit = compilationUnit.AddMembers(items: enumObjectClass);
                }
                else
                {
                    // var systemNamespace = compilation.GlobalNamespace
                    //                                  .GetNamespaceMembers()
                    //                                  .FirstOrDefault(n => n.Name == "System");
                    // if (systemNamespace != null)
                    // {
                    //     var componentModelNamespace = systemNamespace.GetNamespaceMembers()
                    //                                                  .FirstOrDefault(n => n.Name == "ComponentModel");
                    //     if (componentModelNamespace == null)
                    //     {
                    //         return;
                    //     }
                    // }
                    // else
                    // {
                    //     return;
                    // }
                    
                    var usings               = UsingDirective(IdentifierName("System.ComponentModel"));
                    var namespaceDeclaration = NamespaceDeclaration(name: IdentifierName(name: ns));
                    namespaceDeclaration = namespaceDeclaration.AddMembers(items: enumObjectClass);

                    compilationUnit = compilationUnit.AddUsings(usings)
                                                     .AddMembers(items: namespaceDeclaration);
                }


                var code = compilationUnit.NormalizeWhitespace()
                                          .WithLeadingTrivia(trivia: ParseLeadingTrivia(text: "/// <auto-generated/>\n#nullable enable\n"))
                                          .ToFullString();

                var className = enumObjectClass.Identifier;

                context.AddSource(hintName: $"{className}.g.cs", sourceText: SourceText.From(text: code, encoding: Encoding.UTF8));
            }
        }
        catch (Exception ex)
        {
            ReportExceptionDiagnostic(context: context,
                                      exception: ex,
                                      diagnosticFactory: e => CreateExceptionDiagnostic(exception: e, location: null));
        }
    }

    private static ClassDeclarationSyntax GenerateClass(ClassRegistration classRegistration)
    {
        var className = classRegistration.ClassName;

        var fields = new List<MemberDeclarationSyntax>();

        foreach (var classItem in classRegistration.Items)
        {
            fields.Add(ParseMemberDeclaration(
                                              $$"""
                                                public {{classItem.FieldType}} {{classItem.FieldName}}
                                                            {
                                                                get => {{classItem.FieldName}}BackingField;
                                                        
                                                                set
                                                        
                                                                {
                                                                    {{classItem.FieldName}}BackingField = value;
                                                                    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof({{classItem.FieldName}})));
                                                            
                                                                }
                                                        
                                                            }
                                                """)!);
        }

        var classNameType = ParseTypeName("INotifyPropertyChanged");

        return ClassDeclaration(className)
               .AddBaseListTypes(SimpleBaseType(classNameType))
               .AddModifiers(Token(SyntaxKind.PartialKeyword))
               .AddMembers(fields.ToArray())
               .AddMembers();
    }

    private static readonly DiagnosticDescriptor UnhandledException =
        new("XX0002",
            "Unhandled exception occurred",
            "The generator caused an exception {0}: {1} {2}",
            "error",
            DiagnosticSeverity.Warning,
            true);

    private static Diagnostic CreateExceptionDiagnostic(
        Exception exception,
        Location? location)
        => Diagnostic.Create(UnhandledException,
                             location,
                             exception.GetType(),
                             exception.Message,
                             exception.StackTrace);

    private static void ReportExceptionDiagnostic(
        SourceProductionContext context,
        Exception exception,
        Func
            <Exception, Diagnostic> diagnosticFactory)
    {
        try
        {
            var diagnostic = diagnosticFactory(exception);
            context.ReportDiagnostic(diagnostic);
        }
        catch
        {
        }
    }

    private struct ClassRegistration
    {
        public string? ClassNamespace { get; }

        public string ClassName { get; }

        public List<PropertyItem> Items { get; }

        public ClassRegistration(string? classNamespace, string className, List<PropertyItem> items)
        {
            ClassNamespace = classNamespace;
            ClassName      = className;
            Items          = items;
        }
    }

    private struct PropertyItem(string fieldName, string fieldType)
    {
        public string FieldName { get; } = fieldName;

        public string FieldType { get; } = fieldType;
    }
}